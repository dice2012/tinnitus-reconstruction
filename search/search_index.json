{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tinnitus reconstruction via reverse correlation","text":"<p>This project works to develop a method for characterizing the sounds  experienced by tinnitus patients with potential for characterizing a  wider range of sounds than currently possible.  The approach is based on reverse correlation, an established behavioral  method widely used in psychophysics for unconstrained  characterization of internal perceptual representations.</p> <p></p>"},{"location":"ata/","title":"ATA Target Sounds","text":"<p>The files within the <code>tinnitus-project/experiment/ATA</code> directory are the shortened versions of those presented on the American Tinnitus Association website (here).  They are representitive of the range of sounds experienced by those with tinnitus and function in this project as the target sound for A-X protocol experiments. These are used for experimental protocols where the subject is tasked with matching a target stimulus (\"A-X\" protocols). </p>"},{"location":"docs_styleguide/","title":"Documentation Styleguide","text":"<p>This is a styleguide for the documentation of tinnitus-project.  Documentation is created by running <code>build_docs.py</code>, which processes every <code>.m</code> file in the repository. This guide is intended as both a reference for consistency of documentation and syntax processable by <code>build_docs.py</code>.</p>"},{"location":"docs_styleguide/#header-files","title":"Header Files","text":"<p>In order for documentation to be written for the contents of a directory, there must exist a file in the <code>tinnitus-project/docs</code> directory named <code>dirname-head.md</code>, where <code>dirname</code> is the name of the directory for which the documentation is being generated.  The contents of this file will be placed at the beginning of the documentation page, after which in-file documentation will be written.  This header file is only editable directly and is not overwritten at each regeneration of the documentation. </p>"},{"location":"docs_styleguide/#beginning-documentaiton","title":"Beginning Documentaiton","text":"<p>For all functions and scripts, the documentation must be in the form of comments preceeding all code in the file (Abstract Class Documentation is an exception to this).  In order for a code file to be incorporated into the documentation, the filename, excluding <code>.m</code> must be written at the beginning of the documentation text.  Be sure to place three <code>#</code> signs in front of the filename so that the file is formatted as \"Heading level 3\". For example, documentation for <code>Protocol.m</code> would begin with: <code>% ### Protocol</code>.</p> <p>Note</p> <p>Documentation will still be created so long as the filename is present, regardless of heading style.</p> <p>If one wishes to exclude documentation from the site for any reason, simply do not put the filename as a standalone comment line.</p>"},{"location":"docs_styleguide/#ending-documentation","title":"Ending Documentation","text":"<p>For all functions and scripts, the recorded documentation will end at the beginning of the code.  However, for scripts (which do not have a clear <code>function</code> demarcation for the beginning of the code), it is best practice to mark the desired end of the documentation with <code>% End of documentation</code> (case insensitive). This will avoid capturing any code-specific comments, such as section headers, in the documentation.</p>"},{"location":"docs_styleguide/#formatting","title":"Formatting","text":"<p>At minimum, all documentation should include two things:</p> <ul> <li>A description of the purpose of the code<ul> <li>Plain English description of what the code does.</li> </ul> </li> <li>A list of outputs<ul> <li>Written with the header <code>**OUTPUTS:**</code> followed by a blank new line and the ouputs listed on subsequent lines with <code>-</code> markers. Place a colon before the output description and enclose any dimensionality information (e.g., matrix size) within backticks.  Scripts should also have outputs listed even for figures, saved files, etc. See the here for an example.</li> </ul> </li> </ul> <p>Additional information may include:</p> <ul> <li>An example of a function call<ul> <li>This is most useful if there are optional arguments to illustrate the ways in which the function may be called. Enclose the example using a fenced code block as in: <pre><code>```matlab\nfunction call example\n```\n</code></pre></li> </ul> </li> <li>A list of arguments<ul> <li>Written with the header <code>**ARGUMENTS:**</code> followed by a blank new line and the arguments listed on subsequent lines with <code>-</code> markers. Place a colon before the argument description and enclose any dimensionality information (e.g., matrix size) within backticks.  Be sure to note optional arguments and their default values. See the here for an example.</li> </ul> </li> <li> <p>A \"See Also\" section</p> <ul> <li>A list of other functions relevant to the current file.  Write <code>See Also:</code> (case insensitive, colon not necessary) on its own line followed by the relevant filenames on subsequent, individual lines. Documentation will autoformat to the proper call-out box. </li> </ul> <p>For basic scripts and functions, just write the filename: <pre><code>% See Also: \n% collect_reconstructions\n% collect_data\n% config2table\n</code></pre> Class methods must be written as <code>classname.method</code>: <pre><code>% See Also: \n% PowerDistributionStimulusGeneration.from_file\n</code></pre> To preformat the reference, use the syntax <code>* [reference](link)</code>,  where <code>reference</code> is the text that will be hyperlinked, and <code>link</code> is the redirection location.  This is useful for references to other repositories or documentation: <pre><code>% See Also: \n% * [ReadYaml](https://github.com/llerussell/ReadYAML/blob/master/ReadYaml.m)\n</code></pre></p> </li> </ul>"},{"location":"docs_styleguide/#example","title":"Example","text":"<p>An example of a fully documented and formatted function:</p> <pre><code>% ### binnedrepr2spect  \n% \n% ```matlab\n%   T = binnedrepr2spect(binned_repr, B)\n%   T = binnedrepr2spect(binned_repr, B, n_bins)\n% ```\n%\n% Get the stimuli spectra from a binned representation.\n%\n% **ARGUMENTS:**\n% \n%   - binned_repr: `n_trials x n_bins` matrix\n%       representing the amplitude in each frequency bin\n%       for each trial.\n%   - B: `1 x n_frequencies` vector\n%       representing the bin numbers\n%       (e.g., `[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]`)\n%   - n_bins: `1 x 1` scalar\n%       representing the number of bins\n%       if not passed as an argument,\n%       it is computed from the maximum of B\n% \n% **OUTPUTS:**\n% \n%   - T: `n_trials x n_frequencies` matrix\n%       representing the stimulus spectra\n% \n% See Also:\n% spect2binnedrepr\n</code></pre> <p>Note</p> <p>Be sure to avoid too much text on a single line so as to maintain readability of the documentation within the file itself.</p>"},{"location":"docs_styleguide/#abstract-class-documentation","title":"Abstract Class Documentation","text":"<p>For abstract classes, the preferred documentation style is slightly different.  Because the abstract methods are all written within the same file, it improves code readability to keep the documentation inside each function, rather than before the <code>function</code> statement as done elsewhere.  Choosing to place comments before or after the <code>function</code> statement does not affect the generated documentation, only the readability for those working directly with the code. </p>"},{"location":"experiment-head/","title":"Experiment","text":"<p>This folder contains the files necessary to run an experimental protocol. Most important for the majority of users is the config file and the <code>Protocol</code> function.</p>"},{"location":"experiment-head/#configs","title":"Configs","text":"<p>Config files contain all of the information necessary to run trials and gather data. Configs are in <code>.yaml</code> format. These files should be carefully written before beginning any experiment to ensure the desired stimulus is generated and data are labeled and stored as intended. The name of the config file itself does not require a specific format. </p> <p>To allow for unique naming and organization, label experiment name and subject ID fields. These are not required fields for performing the experiment, but are highly encouraged. </p> <pre><code>experiment_name: paper1-buzzing-AH\nsubject_ID: AH\n</code></pre> <p>These fields describe the number of trials in the experiment. <code>n_trial_per_block</code> is the number of trials per block of the experiment. A block is a set of contiguous trials without a break a break. Subjects get a break between blocks. These are both required fields.</p> <pre><code>n_trials_per_block: 100\nn_blocks: 20\n</code></pre> <p>The total trials should be the number of trials per block times the number of blocks. This is not a required field.</p> <pre><code>total_trials: 2000\n</code></pre> <p>These \"freq\" fields describe the frequency range of the stimuli, including the minimum frequency and maximum frequency, both in Hz. The duration field describes the duration of the stimului in seconds. These are not required fields. Default values are set to <code>min_freq = 100, max_freq = 22000, and duration = 0.5</code>. These defaults are defined in the Abstract Stimulus Generation Class.</p> <pre><code>min_freq: 100\nmax_freq: 13000\nduration: 0.5\n</code></pre> <p>For a stimulus type that uses bins, the number of bins are set here. This should be a positive scalar integer.</p> <pre><code>n_bins: 100\n</code></pre> <p>This required parameter gives the stimuli type. The name is the class that defines the stimuli type without \"StimulusGeneration\".</p> <pre><code>stimuli_type: UniformPrior\n</code></pre> <p>Some stimulus generation methods have other parameters associated with them. For example, the Gaussian Prior stimulus generation method requires an n_bins_filled_mean and n_bins_filled_var property. You can see what extra parameters are required for your method by inspecting the class definition for the method (see \"Stimulus Generation\" section). If you do not overwrite values in the config, default values are used, which are described in the class definition.</p> <pre><code>min_bins: 30\nmax_bins: 30\n</code></pre> <p>For an experiment with a target signal (i.e., for pilot subjects) this field describes the full filepath to the target signal audio file.</p> <pre><code>target_audio_filepath: /home/alec/code/tinnitus-project/code/experiment/ATA/ATA_Tinnitus_Buzzing_Tone_1sec.wav\nbin_target_signal: true\n</code></pre> <p>This is the path where the output files are saved. This is not a required field. If it is is unset, it will default to <code>tinnitus-project/code/experiment/Data</code>.</p> <pre><code>data_dir: /home/alec/code/tinnitus-project/code/experiment/Data/data_pilot\n</code></pre> <p>This field determines in what form the stimuli are saved. The available options are <code>bins</code>, <code>waveform</code>, or <code>spectrum</code>. If not set, it will default to <code>waveform</code>.</p> <pre><code>stimuli_save_type: bins\n</code></pre> <p>This field indicates whether follow up questions should be asked. If it is unset, it will default to <code>false</code>.</p> <pre><code>follow_up: true\n</code></pre> <p>This field indicates what version of follow up questions to use. If it is unset, it will default to <code>1</code>. Follow up questions can be found in  <code>tinnitus-project/code/experiment/fixationscreen/FollowUp_vX</code>, where <code>X</code> is the version number. </p> <pre><code>follow_up_version: 1\n</code></pre>"},{"location":"experiment/","title":"Experiment","text":"<p>This folder contains the files necessary to run an experimental protocol. Most important for the majority of users is the config file and the <code>Protocol</code> function.</p>"},{"location":"experiment/#configs","title":"Configs","text":"<p>Config files contain all of the information necessary to run trials and gather data. Configs are in <code>.yaml</code> format. These files should be carefully written before beginning any experiment to ensure the desired stimulus is generated and data are labeled and stored as intended. The name of the config file itself does not require a specific format. </p> <p>To allow for unique naming and organization, label experiment name and subject ID fields. These are not required fields for performing the experiment, but are highly encouraged. </p> <pre><code>experiment_name: paper1-buzzing-AH\nsubject_ID: AH\n</code></pre> <p>These fields describe the number of trials in the experiment. <code>n_trial_per_block</code> is the number of trials per block of the experiment. A block is a set of contiguous trials without a break a break. Subjects get a break between blocks. These are both required fields.</p> <pre><code>n_trials_per_block: 100\nn_blocks: 20\n</code></pre> <p>The total trials should be the number of trials per block times the number of blocks. This is not a required field.</p> <pre><code>total_trials: 2000\n</code></pre> <p>These \"freq\" fields describe the frequency range of the stimuli, including the minimum frequency and maximum frequency, both in Hz. The duration field describes the duration of the stimului in seconds. These are not required fields. Default values are set to <code>min_freq = 100, max_freq = 22000, and duration = 0.5</code>. These defaults are defined in the Abstract Stimulus Generation Class.</p> <pre><code>min_freq: 100\nmax_freq: 13000\nduration: 0.5\n</code></pre> <p>For a stimulus type that uses bins, the number of bins are set here. This should be a positive scalar integer.</p> <pre><code>n_bins: 100\n</code></pre> <p>This required parameter gives the stimuli type. The name is the class that defines the stimuli type without \"StimulusGeneration\".</p> <pre><code>stimuli_type: UniformPrior\n</code></pre> <p>Some stimulus generation methods have other parameters associated with them. For example, the Gaussian Prior stimulus generation method requires an n_bins_filled_mean and n_bins_filled_var property. You can see what extra parameters are required for your method by inspecting the class definition for the method (see \"Stimulus Generation\" section). If you do not overwrite values in the config, default values are used, which are described in the class definition.</p> <pre><code>min_bins: 30\nmax_bins: 30\n</code></pre> <p>For an experiment with a target signal (i.e., for pilot subjects) this field describes the full filepath to the target signal audio file.</p> <pre><code>target_audio_filepath: /home/alec/code/tinnitus-project/code/experiment/ATA/ATA_Tinnitus_Buzzing_Tone_1sec.wav\nbin_target_signal: true\n</code></pre> <p>This is the path where the output files are saved. This is not a required field. If it is is unset, it will default to <code>tinnitus-project/code/experiment/Data</code>.</p> <pre><code>data_dir: /home/alec/code/tinnitus-project/code/experiment/Data/data_pilot\n</code></pre> <p>This field determines in what form the stimuli are saved. The available options are <code>bins</code>, <code>waveform</code>, or <code>spectrum</code>. If not set, it will default to <code>waveform</code>.</p> <pre><code>stimuli_save_type: bins\n</code></pre> <p>This field indicates whether follow up questions should be asked. If it is unset, it will default to <code>false</code>.</p> <pre><code>follow_up: true\n</code></pre> <p>This field indicates what version of follow up questions to use. If it is unset, it will default to <code>1</code>. Follow up questions can be found in  <code>tinnitus-project/code/experiment/fixationscreen/FollowUp_vX</code>, where <code>X</code> is the version number. </p> <pre><code>follow_up_version: 1\n</code></pre>"},{"location":"experiment/#protocol","title":"Protocol","text":"<p>Reverse Correlation Protocol for Cognitive Representations of Speech</p> <p>This function runs the experimental procedure of this project.</p> <p>It can be called in two ways: <pre><code>Protocol() or Protocol('config', 'path2config')\n</code></pre> Where <code>'path2config'</code> is the file path to the desired config file.</p> <p>If <code>Protocol()</code> is invoked, a GUI is automatically opened for the user to select the proper config file.</p>"},{"location":"install/","title":"Installation and setup guide","text":"<p>For most users, it is best to install the MATLAB toolbox from the latest Release. For development, clone the following projects:</p> <ul> <li>mtools</li> <li>tinnitus-project</li> <li>ReadYAML (only for legacy use)</li> <li>yaml</li> </ul> <p>Then add the functions to your path. The commands should look similar to this:</p> <pre><code>addpath ~/code/yaml\naddpath ~/code/srinivas.gs_mtools/src\nsavepath\n</code></pre> <p>Finally, in the <code>tinnitus-project/code</code> directory, run <code>setup.m</code> as a MATLAB script.</p>"},{"location":"scripts-head/","title":"Scripts","text":"<p>Housed within this folder are data processing and analysis scripts. </p>"},{"location":"scripts/","title":"Scripts","text":"<p>Housed within this folder are data processing and analysis scripts. </p>"},{"location":"scripts/#hyperparameter_sweep_custom","title":"hyperparameter_sweep_custom","text":"<p>Hyperparameter Sweep Custom Stimulus</p> <p>Evaluate hyperparameters of stimulus generation using the 'custom' stimulus paradigm. Evaluate hyperparameters over different target signals.</p>"},{"location":"scripts/#pilot_reconstructions","title":"pilot_reconstructions","text":"<p>Compute reconstructions for the pilot data experiment. This code assumes that each each experiment uses the same number of bins and that the reconstructions should be done over the bin representation.</p> <p>OUTPUTS: - T: a data table that contains information about the experiments and their reconstructions</p>"},{"location":"stimulus_generation-head/","title":"Stimulus generation head","text":"<p>This is sample header text for stimulus_generation-head</p>"},{"location":"utils-head/","title":"Utilities","text":"<p>This folder stores many helpful, and in some cases critical utilities. This folder as added to the path via <code>setup.m</code>. Some files are not original to this project, in which case documentation and credit is clearly maintained.</p>"},{"location":"utils/","title":"Utilities","text":"<p>This folder stores many helpful, and in some cases critical utilities. This folder as added to the path via <code>setup.m</code>. Some files are not original to this project, in which case documentation and credit is clearly maintained.</p>"},{"location":"utils/#adjust_volume","title":"adjust_volume","text":"<p>For use in A-X experimental protocols. <code>adjust_volume</code> is a utility to dynamically adjust the target sound volume via a scaling factor. Opens a GUI using a standard MATLAB figure window  with a slider for scaling the target sound audio  and a button for replaying the sound compared to an unchanged stimulus noise.  </p> <p>ARGUMENTS:</p> <ul> <li>target_sound: <code>n x 1</code> vector, the target sound.</li> <li>target_fs: <code>1 x 1</code> scalar, the frequency of target_sound.</li> <li>stimuli: <code>n x 1</code> vector, a sample stimulus sound.</li> <li>Fs: <code>1 x 1</code> scalar, the frequency of the sample stimuli.</li> <li>scale_factor: <code>1 x 1</code> scalar, the scalar by which to multipy the target sound. default: <code>1.0</code>.</li> </ul> <p>OUTPUTS:</p> <ul> <li>scale_factor: <code>1 x 1</code> scalar,  the scalar by which the target signal is multipled  that results in the preferred volume chosen by the user.</li> </ul>"},{"location":"utils/#allcomb","title":"allcomb","text":"<p>ALLCOMB - All combinations B = ALLCOMB(A1,A2,A3,...,AN) returns all combinations of the elements in the arrays A1, A2, ..., and AN. B is P-by-N matrix is which P is the product of the number of elements of the N inputs. This functionality is also known as the Cartesian Product. The arguments can be numerical and/or characters, or they can be cell arrays.</p> <p>Examples:</p> <pre><code>allcomb([1 3 5],[-3 8],[0 1]) % numerical input:\n-&gt; [ 1  -3   0\n1  -3   1\n1   8   0\n...\n5  -3   1\n5   8   1 ] ; % a 12-by-3 array\n</code></pre> <pre><code>allcomb('abc','XY') % character arrays\n-&gt; [ aX ; aY ; bX ; bY ; cX ; cY] % a 6-by-2 character array\n</code></pre> <pre><code>allcomb('xy',[65 66]) % a combination\n-&gt; ['xA' ; 'xB' ; 'yA' ; 'yB'] % a 4-by-2 character array\n</code></pre> <pre><code>allcomb({'hello','Bye'},{'Joe', 10:12},{99999 []}) % all cell arrays\n-&gt; {  'hello'  'Joe'        [99999]\n'hello'  'Joe'             []\n'hello'  [1x3 double] [99999]\n'hello'  [1x3 double]      []\n'Bye'    'Joe'        [99999]\n'Bye'    'Joe'             []\n'Bye'    [1x3 double] [99999]\n'Bye'    [1x3 double]      [] } ; % a 8-by-3 cell array\n</code></pre> <p><code>ALLCOMB(..., 'matlab')</code> causes the first column to change fastest which is consistent with matlab indexing.  Example:  <pre><code>allcomb(1:2,3:4,5:6,'matlab') -&gt; [ 1 3 5 ; 1 4 5 ; 1 3 6 ; ... ; 2 4 6 ]\n</code></pre></p> <p>If one of the arguments is empty, ALLCOMB returns a <code>0-by-N</code> empty array.</p> <p>Tested in Matlab R2015a version 4.1 (feb 2016) (c) Jos van der Geest email: samelinoa@gmail.com</p> <p>History:</p> <p>1.1 (feb 2006), removed minor bug when entering empty cell arrays; added option to let the first input run fastest (suggestion by JD)</p> <p>1.2 (jan 2010), using ii as an index on the left-hand for the multiple output by NDGRID. Thanks to Jan Simon, for showing this little trick</p> <p>2.0 (dec 2010). Bruno Luong convinced me that an empty input should return an empty output.</p> <p>2.1 (feb 2011). A cell as input argument caused the check on the last argument (specifying the order) to crash.</p> <p>2.2 (jan 2012). removed a superfluous line of code (ischar(..))</p> <p>3.0 (may 2012) removed check for doubles so character arrays are accepted</p> <p>4.0 (feb 2014) added support for cell arrays</p> <p>4.1 (feb 2016) fixed error for cell array input with last argument being <code>matlab</code>. Thanks to Richard for pointing this out.</p> <p>See Also</p> <ul> <li>NCHOOSEK </li> <li>PERMS</li> <li>NDGRID</li> <li>NCHOOSE</li> <li>KTHCOMBN</li> </ul>"},{"location":"utils/#binnedrepr2spect","title":"binnedrepr2spect","text":"<pre><code>T = binnedrepr2spect(binned_repr, B)\nT = binnedrepr2spect(binned_repr, B, n_bins)\n</code></pre> <p>Get the stimuli spectra from a binned representation.</p> <p>ARGUMENTS:</p> <ul> <li>binned_repr: <code>n_trials x n_bins</code> matrix representing the amplitude in each frequency bin for each trial.</li> <li>B: <code>1 x n_frequencies</code> vector representing the bin numbers (e.g., <code>[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]</code>)</li> <li>n_bins: <code>1 x 1</code> scalar representing the number of bins if not passed as an argument, it is computed from the maximum of B</li> </ul> <p>OUTPUTS:</p> <ul> <li>T: <code>n_trials x n_frequencies</code> matrix representing the stimulus spectra</li> </ul> <p>See Also</p> <ul> <li>spect2binnedrepr</li> </ul>"},{"location":"utils/#collect_parameters","title":"collect_parameters","text":"<p>Read parameters out from character vectors of text contained in a character vector or cell array.</p> <p>ARGUMENTS:</p> <ul> <li>filenames: <code>cell array</code> of character vectors or <code>character vector</code> that contains the filenames (or text strings) out of which to read parameters.</li> </ul> <p>If <code>filenames</code> is a cell array, parameters are read from each character vector contained in the cell array. Filenames should not have file endings like <code>'.csv'</code>. The regular expressions are not sophisticated enough to skip them.</p> <p>OUTPUTS:</p> <ul> <li>data_table: <code>table</code></li> </ul> <p>Example:</p> <pre><code>data_table = collect_parameters(filenames)\n</code></pre> <p>See Also</p> <ul> <li>collect_reconstructions</li> <li>collect_data</li> <li>config2table</li> </ul>"},{"location":"utils/#collect_reconstructions","title":"collect_reconstructions","text":"<p>Collect reconstructions (or other data) from <code>.csv</code> files following a naming convention. Returns a matrix of all the data.</p> <p>While this function was intended to read reconstructions, it should be able to return data from any <code>.csv</code> files containing data that can be represented in a MATLAB matrix (e.g., numerical data of the same length).</p> <p>ARGUMENTS:</p> <ul> <li>data_struct: struct vector or character vector A struct containing the output of a call to <code>dir()</code> indicating which files to extract from or a character vector which is used as an argument for <code>dir()</code> (e.g., <code>dir(data_struct)</code>). The regular expression is used to filter the data struct based on the filenames.</li> </ul> <p>OUTPUTS:</p> <ul> <li> <p>reconstructions: numerical matrix <code>m x n</code> matrix that contains the numerical data, where <code>m</code> is the length of the data and <code>n</code> is the number of files.</p> </li> <li> <p>reconstruction_files: cell array of character vectors Contains the filepaths to each file read, corresponding to the columns of <code>reconstructions</code>.</p> </li> </ul> <p>See Also</p> <ul> <li>collect_data</li> <li>dir</li> </ul>"},{"location":"utils/#config2table","title":"config2table","text":"<p>Take information from directory containing config files and return a table with all relevant information for each config.</p> <p>ARGUMENTS: </p> <ul> <li> <p>curr_dir: <code>struct</code>,  which is the directory information  containing config file name, path, and other returns from <code>dir()</code> function.</p> </li> <li> <p>variables_to_remove: <code>cell</code>, default: <code>{}</code>, a cell array of character vectors, indicating which variables (columns) of the data table to remove. If empty, re-defaults to: <code>{'n_trials_per_block', 'n_blocks', ... 'min_freq', 'max_freq', 'duration', 'n_bins', ... 'target_signal_filepath', 'bin_target_signal', ... 'data_dir', 'stimuli_save_type'}</code>.</p> </li> </ul> <p>OUTPUTS: </p> <ul> <li>data_table: <code>table</code></li> </ul> <p>See Also</p> <ul> <li>parse_config</li> <li>dir</li> </ul>"},{"location":"utils/#create_files_and_stimuli","title":"create_files_and_stimuli","text":"<p>Create files for the stimuli, responses, and metadata and create the stimuli. Write the stimuli into the stimuli file.</p> <p>See Also</p> <ul> <li>Protocol</li> </ul>"},{"location":"utils/#crossval_predicted_responses","title":"crossval_predicted_responses","text":"<p>Generate response predictions for a given config file using stratified cross validation.</p> <pre><code>[given_resps, training_resps, on_test, on_train] = crossval_predicted_responses(config, folds, data_dir)\n[given_resps, training_resps, on_test, on_train] = crossval_predicted_responses(config, folds, data_dir, 'knn', true, 'knn_vals', 2:3:15, 'mean_zero', true)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>config: <code>struct</code>, config struct from which to find responses and stimuli</p> </li> <li> <p>folds: <code>scalar</code> positive integer, must be greater than 3, representing the number of cross validation folds to complete. Data will be partitioned into <code>1/folds</code> for <code>test</code> and <code>dev</code> sets and the remaining for the <code>train</code> set.</p> </li> <li> <p>data_dir: <code>char</code>, the path to directory in which the data corresponding to the  config structis stored.</p> </li> <li> <p>knn: <code>bool</code>, name-value, default: <code>false</code>, flag to run additional K-Nearest-Neighbor analysis</p> </li> <li> <p>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, flag to set the mean of the stimuli to zero when computing the reconstruction and both the mean of the stimuli and the reconstruction to zero when generating the predictions.</p> </li> <li> <p>from_responses: <code>bool</code>, name-value, default: <code>false</code>, flag to determine the threshold from the given responses.  Overwrites <code>threshold_values</code> and does not run threshold development cycle.</p> </li> <li> <p>ridge_reg: <code>bool</code>, name-value, default: <code>false</code>, flag to use ridge regression instead of standard linear regression for reconstruction.</p> </li> <li> <p>threshold_values: <code>1 x m</code> numerical vector, name-value, default: <code>linspace(10,90,200)</code>, representing the percentile threshold values on which to perform development to identify optimum.  Values must be on (0,100].</p> </li> <li> <p>k_vals: <code>1 x n</code> numerical vector, name-value, default: <code>10:5:50</code>, representing the K values on which to perform development to identify optimum for KNN analysis. Values must be positive integers.</p> </li> <li> <p>verbose: <code>bool</code>, name-value, default: <code>true</code>, flag to print information messages.       </p> </li> </ul> <p>OUTPUTS:</p> <ul> <li> <p>given_resps: <code>p x 1</code> vector, the original subject responses in the order corresponding  to the predicted responses, i.e., a shifted version of the  original response vector. <code>p</code> is the number of original responses.</p> </li> <li> <p>training_resps: <code>(folds-2)*p x 1</code> vector, the original subject responses used in the training phase. The training data is partially repeated between folds.</p> </li> <li> <p>on_test: <code>struct</code> with <code>p x 1</code> vectors in fields <code>cs</code>, <code>lr</code>, and if <code>knn = true</code>, <code>knn</code>. Predicted responses on testing data.</p> </li> <li> <p>on_train: <code>struct</code> with <code>(folds-2)*p x 1</code> vectors in fields <code>cs</code>, <code>lr</code>, and if <code>knn = true</code>, <code>knn</code>. Predicted responses on training data.</p> </li> </ul>"},{"location":"utils/#cs","title":"cs","text":"<pre><code>[x] = cs(responses, Phi, Gamma)\n[x] = cs(responses, Phi)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>responses: <code>n x 1</code> vector</p> </li> <li> <p>Phi: <code>n x m</code> matrix, where <code>n</code> is the number of trials/samples and <code>m</code> is the dimensionality of the stimuli/spectrum/bins</p> </li> <li> <p>Gamma: Positive scalar, default: 32 optional value for zhangpassivegamma function.</p> </li> <li> <p>mean_zero: <code>bool</code>, name-value, default: <code>false</code>, a flag for setting the mean of <code>Phi</code> to zero.</p> </li> <li> <p>verbose: <code>bool</code>, name-value, default: <code>true</code>, a flag to print information messages</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>x: <code>m x 1</code> vector, representing the compressed sensing reconstruction of the signal.</li> </ul>"},{"location":"utils/#disp_fullscreen","title":"disp_fullscreen","text":"<p>Fill full screen figure with new image.</p> <p>ARGUMENTS:</p> <ul> <li>img: image loaded via imread()</li> <li>hFig: handle to maximized figure.  Defaults to current figure handle.</li> </ul> <p>OUTPUTS:</p> <ul> <li>hFig now displays an image.</li> </ul>"},{"location":"utils/#filematch","title":"filematch","text":"<p>Match files by terminal UUID or other identifier. This function expects filenames in the form</p> <p><code>foo_bar_UUID.baz</code></p> <p>Where foo_bar can be anything, so long as the UUID or other identifier comes last before the 'dot filetype'. The functions returns indices of unmatched files.</p> <p>Example:</p> <p><code>filematch(files1, files2)</code></p> <p>See Also</p> <ul> <li>collect_data</li> </ul>"},{"location":"utils/#follow_up","title":"follow_up","text":"<p>Runs the follow up protocol to ask exit survey questions Questions are included in code/experiment/fixationscreens/FollowUp_vX Where X is the version number. Also asks reconstruction quality assessment. Computes linear reconstruction and generates config-informed white noise for comparison against target sound. Responses are saved in the specified data directory. </p> <p>ARGUMENTS:</p> <ul> <li>data_dir: character vector, name-value, default: empty Directory where data is stored. If blank, config.data_dir is used. </li> <li>project_dir: character vector, name-value, default: empty Set as an input to reduce tasks if running from <code>Protocol.m</code>.</li> <li>this_hash: character vector, name-value, default: empty Hash to use for output file. Generates from config if blank.</li> <li>target_sound: numeric vector, name-value, default: empty Target sound for comparison. Generates from config if blank.</li> <li>target_fs: Positive scalar, name-value, default: empty Frequency associated with target_sound</li> <li>n_trials: Positive number, name-value, default: inf Number of trials to use for reconstruction. Uses all data if <code>inf</code>.</li> <li>version: Positive number, name-value, default: 1 Question version number.</li> <li>config_file: character vector, name-value, default: <code>''</code> A path to a YAML-spec configuration file.</li> <li>fig: matlab.ui.Figure, name-value. Handle to open figure on which to display questions.</li> <li>verbose: logical, name-value, default: <code>true</code> Flag to print information and warnings. </li> </ul> <p>OUTPUTS:</p> <ul> <li>survey_XXX.csv: csv file, where XXX is the config hash. In the data directory. </li> </ul>"},{"location":"utils/#get_accuracy_measures","title":"get_accuracy_measures","text":"<p>Computes standard accuracy measures between true and predicted labels</p> <p>ARGUMENTS:</p> <ul> <li> <p>y: <code>m x n</code> numerical matrix, representing true labels. Values must be either <code>1</code> or <code>-1</code>.</p> </li> <li> <p>y_hat: <code>m x n</code> numerical matrix, representing predicted labels. Values must be either <code>1</code> or <code>-1</code>.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li> <p>accuracy: <code>scalar</code>, the correct prediction rate.</p> </li> <li> <p>balanced_accuracy: <code>scalar</code>, the average of <code>sensitivity</code> and <code>specificity</code>.</p> </li> <li> <p>sensitivity: <code>scalar</code>, the true positive rate.</p> </li> <li> <p>specificity: <code>scalar</code>, the true negative rate.</p> </li> </ul>"},{"location":"utils/#get_highest_power_of_2","title":"get_highest_power_of_2","text":"<p>Compute the highest power of two less than or equal to a number. For example, an input of 9 would return 8.</p> <p>EXAMPLE:</p> <pre><code>n = get_highest_power_of_2(N);\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>N: a 1x1 scalar, positive, real integer</li> </ul> <p>OUTPUTS:</p> <ul> <li>n: a 1x1 scalar, positive, real power of 2</li> </ul>"},{"location":"utils/#get_reconstruction","title":"get_reconstruction","text":"<p>Compute reconstructions using data specified by a configuration file.</p> <pre><code>[x, responses_output, stimuli_matrix_output] = get_reconstruction('key', value, ...)\nx = get_reconstruction('config_file', 'path_to_config', 'preprocessing', {'bit_flip'}, 'method', 'cs', 'verbose', true)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li>config_file: string or character array, name-value, default: <code>''</code> A path to a YAML-spec configuration file. Either this argument or <code>config</code> is required.</li> <li>config: struct, name-value, default: <code>[]</code> A configuration file struct (e.g., one created by <code>parse_config</code>).</li> <li>preprocessing: cell array of character vectors, name-value, default: <code>{}</code> A list of preprocessing steps to take. Currently, the only supported preprocessing step is <code>'bit flip'</code>, which flips the sign on all responses before computing the reconstruction.</li> <li>method: character vector, name-value, default: <code>'cs'</code> Which reconstruction algorithm to use.  Options: <code>'cs'</code>, <code>'cs_nb'</code>, <code>'linear'`,</code>'linear_ridge'``.</li> <li>use_n_trials: Positive scalar, name-value, default: <code>inf</code> Indicates how many trials to use of data. <code>inf</code> uses all data.</li> <li>bootstrap: Positive scalar, name-value, deafult: 0 Number of bootstrap iterations to perform.</li> </ul> <p>See Also</p> <ul> <li>collect_reconstructions</li> <li>collect_data</li> <li>config2table</li> </ul>"},{"location":"utils/#gs","title":"gs","text":"<p>Returns the linear reconstruction of stimuli and responses.</p> <pre><code>x = gs(responses, Phi)\nx = gs(responses, Phi, 'ridge', true, 'mean_zero', true)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>responses: <code>n x 1</code> vector of 1 and -1 values, representing the subject's responses.</p> </li> <li> <p>Phi: <code>n x m</code> numerical matrix, where m is the length of each stimulus  and n is the same length as the responses</p> </li> <li> <p>ridge: <code>boolean</code>, name-value, default: <code>false</code>, a flag to for using ridge regression.</p> </li> <li> <p>mean_zero: <code>boolean</code>, name-value, defaut: <code>false</code>, a flag for setting the mean of <code>Phi</code> to zero.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>x: <code>m x 1</code> vector, representing the linear reconstruction of the signal,  where m is the length of a stimulus. </li> </ul>"},{"location":"utils/#knn_classify","title":"knn_classify","text":"<p>Returns the estimated class labels for a matrix of  reference points T, given data points X and labels y.</p> <p>ARGUMENTS:</p> <ul> <li>y: <code>n x 1</code> vector, representing class labels that correspond to data points in <code>X</code>.</li> <li>X: <code>n x p</code> numerical matrix, labelled data points.</li> <li>T: <code>m x p</code> numerical matrix, representing reference points without/needing class labels</li> <li>k: <code>scalar</code>, indicating the number of nearest neighbors to be considered.</li> </ul> <p>OUTPUTS:</p> <ul> <li>z_hat: <code>m x 1</code> vector, estimated class labels for data points in T.</li> </ul>"},{"location":"utils/#munge_hashes","title":"munge_hashes","text":"<p>Processes config files, correcting errors. Then, fixes the hashes for saved data files associated with changed config files.</p> <pre><code>munge_hashes(\"file_string\", \"config*.yaml\", \"verbose\", true)\n</code></pre> <p>Arguments:</p> <ul> <li> <p>file_string: <code>string</code> or <code>character vector</code>, name-value, default: <code>\"config*.yaml\"</code> A file pattern, optionally using globs that is passed to <code>dir</code> to search for configuration files to munge.</p> </li> <li> <p>legacy_flag: <code>logical scalar</code>, name-value, default: <code>false</code> Whether to load config files in \"legacy mode\", e.g., with <code>ReadYaml</code> instead of <code>yaml.loadFile</code>.</p> </li> <li> <p>verbose: <code>logical scalar</code>, name-value, default: <code>true</code> Whether to print informative text.</p> </li> <li> <p>data_dir: <code>string</code> or <code>character vector</code>, name-value, default: <code>\".\"</code> Path to the directory where the data files to-be-munged are.</p> </li> </ul> <p>See Also</p> <ul> <li>update_hashes</li> </ul>"},{"location":"utils/#parse_config","title":"parse_config","text":"<p>Read a config file and perform any special parsing that is required.</p> <p>ARGUMENTS:</p> <ul> <li>config_file: character vector, default: [] Path to the config file to be used. If empty, opens a GUI to find the file using a file browser.</li> </ul> <p>OUTPUTS:</p> <ul> <li>varargout: <code>1 x 2</code> cell array: varargout{1} = config: <code>struct</code>, the parsed config file. varargout{2} = config_file OR abs_path, <code>char</code>, if path provided, return the path, else return path chosen from GUI.</li> </ul> <p>See Also</p> <ul> <li>yaml.loadFile</li> </ul>"},{"location":"utils/#prop2str","title":"prop2str","text":"<p>Converts the property names and values of a struct or object into a character vector. For example, a struct, s, with the properties, s.a = 1, s.b = 2, would become 'a=1-b=2'. If some of the property values are cell arrays, they should be character vectors or numerical vectors and of the same type within each cell array.</p> <p>ARGUMENTS:</p> <ul> <li> <p>obj: <code>1 x 1</code> struct or object, the object with properties to be stringified</p> </li> <li> <p>properties_to_skip: character vector or cell array Properties to not include in the output character vector.</p> </li> <li> <p>property_separator: character vector What separator to use between parameter statements.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>stringified_properties: character vector</li> </ul> <p>Example:</p> <pre><code>stringified_properties = prop2str(obj, [], '&amp;&amp;')\n</code></pre> <p>See Also</p> <ul> <li>collect_parameters</li> </ul>"},{"location":"utils/#r_viz","title":"r_viz","text":"<p>Plots bar charts of r values from table data.  A separate figure is made for each subject.</p> <p>ARGUMENTS:</p> <ul> <li>T: <code>table</code> that includes r values of interest</li> </ul> <p>OUTPUTS:</p> <ul> <li>n figures, where n is the number of subjects included in the table.</li> </ul> <p>See Also</p> <ul> <li>pilot_reconstructions</li> </ul>"},{"location":"utils/#spect2binnedrepr","title":"spect2binnedrepr","text":"<p>binned_repr = spect2binnedrepr(T, B) binned_repr = spect2binnedrepr(T, B, n_bins)</p> <p>Get the binned representation, which is a vector containing the amplitude of the spectrum in each frequency bin.</p> <p>ARGUMENTS:</p> <ul> <li> <p>T: <code>n_trials x n_frequencies</code> matrix representing the stimulus spectra</p> </li> <li> <p>B: <code>1 x n_frequencies</code> vector representing the bin numbers (e.g., <code>[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]</code>)</p> </li> <li> <p>n_bins: <code>1x1</code> scalar representing the number of bins if not passed as an argument, it is computed from the maximum of B</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>binned_repr: <code>n_trials x n_bins</code> matrix representing the amplitude for each frequency bin for each trial</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> </ul>"},{"location":"utils/#str2prop","title":"str2prop","text":"<p>Converts a string of properties and values into a struct or cell array. TODO: more documentation, use property_separator</p> <p>ARGUMENTS:</p> <ul> <li> <p>prop_string: character vector String containing property : value pairs</p> </li> <li> <p>properties_to_skip: character vector or cell array Properties to not incude in the output character vector</p> </li> <li> <p>property_separator: character vector What separator to use between parameter statements.</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li>obj: struct or cell array</li> </ul> <p>Example: <pre><code>obj = str2prop(prop_string, [], '&amp;&amp;')\n</code></pre></p> <p>See Also</p> <ul> <li>collect_parameters</li> </ul>"},{"location":"utils/#subject_selection_process","title":"subject_selection_process","text":"<p>Returns a response vector and the stimuli where the response vector is made of up -1 and 1 values corresponding to yes and no statements about how well the stimuli correspond to the representation.</p> <pre><code>y = subject_selection_process(representation, stimuli)\ny = subject_selection_process(representation, stimuli, [], responses, 'mean_zero', true, 'from_responses', true)\ny = subject_selection_process(representation, stimuli, [], [], 'threshold', 90, 'verbose', false)\n[y, X] = subject_selection_process(representation, [], n_samples)\n</code></pre> <p>ARGUMENTS:</p> <ul> <li> <p>representation: <code>n x 1</code> numerical vector, the signal to compare against (e.g., the tinnitus signal).</p> </li> <li> <p>stimuli: numerical matrix, an <code>m x n</code> matrix where m is the number of samples/trials and n is the same length as the representation. If stimuli is empty, a random Bernoulli matrix (p = 0.5) is used.</p> </li> <li> <p>n_samples: integer scalar representing how many samples are used when generating the Bernoulli matrix default for stimuli, if the stimuli argument is empty.</p> </li> <li> <p>responses: <code>m x 1</code> numerical vector,  which contains only <code>-1</code> and <code>1</code> values, used to determine the threshold if using one of the custom options.</p> </li> <li> <p>mean_zero: <code>bool</code>, default: false,  representing a flag that centers the mean of the stimuli and representation.</p> </li> <li> <p>from_responses: <code>bool</code>, name-value, default: <code>false</code>, a flag to determine the threshold from the given responses.  The default results in 50% threshold.  If using this option, <code>responses</code> must be passed as well.</p> </li> <li> <p>threshold: Positive scalar, name-value, default: 50, representing a variable by which to manually set the response threshold. If <code>from_responses</code> is true, this will be ignored.</p> </li> <li> <p>verbose: <code>bool</code>, name-value, default: <code>true</code>, a flag to print information messages</p> </li> </ul> <p>OUTPUTS:</p> <ul> <li> <p>y: numerical vector, A vector of <code>-1</code> and <code>1</code> corresponding to negative and positive responses.</p> </li> <li> <p>X: numerical matrix, the stimuli.</p> </li> </ul> <p>See Also</p> <ul> <li>AbstractStimulusGenerationMethod.subject_selection_process</li> </ul>"},{"location":"utils/#update_hashes","title":"update_hashes","text":"<p>Updates data files that match an old hash to a new hash. Ordinarily this is not something that you want to do. However, there are some situations where the config spec changed or something was mislabeled and so the config hash does not match the hashes in the data file names. This function re-aligns the data to the config by updating the hashes.</p> <p>Arguments:</p> <ul> <li>new_hash: character vector</li> <li>old_hash: character vector</li> <li>data_dir: character vector pointing to the directory where the data files are stored.</li> </ul> <p>Outputs:</p> <ul> <li>None</li> </ul> <p>See Also</p> <ul> <li>collect_data</li> </ul>"},{"location":"utils/#view_table","title":"view_table","text":"<p>Filters data table from <code>pilot_reconstructions.m</code> and generates a figure with a uitable for easy viewing.</p> <p>Arguments:</p> <ul> <li>T: <code>table</code> generated by pilot_reconstructions</li> </ul> <p>OUTPUTS:</p> <ul> <li>1 figure</li> </ul> <p>See Also</p> <ul> <li>pilot_reconstructions</li> </ul>"},{"location":"utils/#wav2spect","title":"wav2spect","text":"<p>Reads an audio file (e.g., a .wav file) and returns a spectrum in terms of magnitudes, s, and frequencies, f, in Hz.</p>"},{"location":"utils/#white_noise","title":"white_noise","text":"<p>Generate a white noise stimulus based on a config file's settings.</p> <p>ARGUMENTS:</p> <ul> <li>config_file: string or character array, name-value, default: <code>''</code> A path to a YAML-spec configuration file. Either this argument or <code>config</code> is required.</li> <li>config: struct, name-value, default: <code>[]</code> A configuration file struct (e.g., one created by <code>parse_config</code>).</li> </ul> <p>OUTPUTS:</p> <ul> <li>white_waveform: <code>n x 1</code> white noise waveform</li> <li>fs: <code>1 x 1</code> Associated frequency of waveform.</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod-head/","title":"Abstract Binned Stimulus Generation Method","text":"<p>Abstract class describing all features common to a stimulus generation method that uses a binned representation of the signal.</p>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod-head/#abstract-properties","title":"Abstract Properties","text":"<p>This property is automatically instantiated for subclasses, since they are not abstract themselves. Default value is given:</p> <pre><code>- n_bins = 100\n</code></pre>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/","title":"Abstract Binned Stimulus Generation Method","text":"<p>Abstract class describing all features common to a stimulus generation method that uses a binned representation of the signal.</p>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#abstract-properties","title":"Abstract Properties","text":"<p>This property is automatically instantiated for subclasses, since they are not abstract themselves. Default value is given:</p> <pre><code>- n_bins = 100\n</code></pre>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#get_freq_bins","title":"get_freq_bins","text":"<pre><code>[binnum, Fs, nfft, frequency_vector] = self.get_freq_bins()\n</code></pre> <p>Generates a vector indicating which frequencies belong to the same bin, following a tonotopic map of audible frequency perception.</p> <p>OUTPUTS:</p> <ul> <li> <p>binnum: <code>n x 1</code> numerical vector that contains the mapping from frequency to bin number e.g., <code>[1, 1, 2, 2, 2, 3, 3, 3, 3, ...]</code></p> </li> <li> <p>Fs: <code>1x1</code> numerical scalar, the sampling rate in Hz</p> </li> <li> <p>nfft: <code>1x1</code> numerical scalar, the number of points of the full FFT</p> </li> <li> <p>frequency_vector: <code>n x 1</code> numerical vector. the frequencies that <code>binnum</code> maps to bin numbers</p> </li> </ul> <p>See Also</p> <ul> <li>AbstractStimulusGenerationMethod.get_fs</li> <li>AbstractStimulusGenerationMethod.get_nfft</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#get_empty_spectrum","title":"get_empty_spectrum","text":"<pre><code>[spect] = self.get_empty_spectrum()\n</code></pre> <p>OUTPUTS:</p> <ul> <li>spect: <code>n x 1</code> numerical vector, where <code>n</code> is equal to the number of fft points (nfft) and all values are set to -100 dB.</li> </ul> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#spect2binnedrepr","title":"spect2binnedrepr","text":"<p>Get the binned representation which is a vector containing the amplitude of the spectrum in each frequency bin.</p> <p>ARGUMENTS:</p> <ul> <li>T: <code>n_frequencies x n_trials</code> matrix representing the stimulus spectra</li> </ul> <p>OUTPUTS:</p> <ul> <li>binned_repr: <code>n_trials x n_bins</code> matrix representing the amplitude for each frequency bin for each trial</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> <li>spect2binnedrepr</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#binnedrepr2spect","title":"binnedrepr2spect","text":"<p>Get the stimuli spectra from a binned representation.</p> <p>ARGUMENTS:</p> <ul> <li>binned_repr: <code>n_bins x n_trials</code> representing the amplitude in each frequency bin for each trial</li> </ul> <p>OUTPUTS:</p> <ul> <li>T: <code>n_frequencies x n_trials</code> representing the stimulus spectra</li> </ul> <p>See Also</p> <ul> <li>binnedrepr2spect</li> <li>spect2binnedrepr</li> </ul>"},{"location":"stimgen/AbstractBinnedStimulusGenerationMethod/#bin_signal","title":"bin_signal","text":"<pre><code>W = self.bin_signal(W)\n</code></pre> <p>Inputs a waveform, converts to a spectrum, bins the spectrum, and then converts back to a waveform.</p> <p>ARGUMENTS:</p> <p>W: <code>n x 1</code> numerical vector, the waveform Fs: <code>1x1</code> numerical scalar, the sample rate</p> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.binnedrepr2spect</li> <li>AbstractBinnedStimulusGenerationMethod.spect2binnedrepr</li> <li>signal2spect</li> </ul>"},{"location":"stimgen/AbstractStimulusGenerationMethod-head/","title":"Abstract Stimulus Generation Method","text":"<p>This is an abstract class describing all features common to a stimulus generation method. In addition to these features, the <code>generate_stimulus</code> method is common to every stimulus generation type. Furthermore this abstract class contains properties common to all stimulus generation methods. </p>"},{"location":"stimgen/AbstractStimulusGenerationMethod-head/#abstract-properties","title":"Abstract Properties","text":"<p>These are automatically instantiated for subclasses, since they are not abstract themselves. Default values are shown here:</p> <pre><code>- min_freq = 100\n- max_freq = 22e3\n- duration = 0.5\n- n_trials = 100\n- Fs = 44.1e3\n</code></pre>"},{"location":"stimgen/AbstractStimulusGenerationMethod/","title":"Abstract Stimulus Generation Method","text":"<p>This is an abstract class describing all features common to a stimulus generation method. In addition to these features, the <code>generate_stimulus</code> method is common to every stimulus generation type. Furthermore this abstract class contains properties common to all stimulus generation methods. </p>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#abstract-properties","title":"Abstract Properties","text":"<p>These are automatically instantiated for subclasses, since they are not abstract themselves. Default values are shown here:</p> <pre><code>- min_freq = 100\n- max_freq = 22e3\n- duration = 0.5\n- n_trials = 100\n- Fs = 44.1e3\n</code></pre>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#subject_selection_process","title":"subject_selection_process","text":"<pre><code>[y, spect, binned_repr] = subject_selection_process(self, signal)\n</code></pre> <p>Model of a subject performing the task. Takes in a signal (the gold standard) and returns an <code>n_samples x 1</code> vector of <code>-1</code> for \"no\" and <code>1</code> for \"yes\".</p>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#generate_stimuli_matrix","title":"generate_stimuli_matrix","text":"<pre><code>[stimuli_matrix, Fs, spect_matrix, binned_repr_matrix] = generate_stimuli_matrix(self)\n</code></pre> <p>Generates a matrix of stimuli. Explicitly calls the <code>generate_stimulus()</code> class method.</p> <p>OUTPUTS:</p> <ul> <li> <p>stimuli_matrix: <code>n x self.n_trials</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</p> </li> <li> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> </li> <li> <p>spect_matrix: <code>m x self.n_trials</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in dB.</p> </li> <li> <p>binned_repr_matrix: <code>self.n_bins x self.n_trials</code> numerical vector, the binned representation.</p> </li> </ul> <p>See Also</p> <ul> <li>BernoulliStimulusGeneration.generate_stimulus</li> <li>BrimijoinStimulusGeneration.generate_stimulus</li> <li>GaussianNoiseNoBinsStimulusGeneration.generate_stimulus</li> <li>GaussianNoiseStimulusGeneration.generate_stimulus</li> <li>GaussianPriorStimulusGeneration.generate_stimulus</li> <li>PowerDistributionStimulusGeneration.generate_stimulus</li> <li>UniformNoiseNoBinsStimulusGeneration.generate_stimulus</li> <li>UniformNoiseStimulusGeneration.generate_stimulus</li> <li>UniformPriorStimulusGeneration.generate_stimulus</li> <li>WeightedPriorStimulusGeneration.generate_stimulus</li> </ul>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#from_config","title":"from_config","text":"<p>Set properties from a struct holding config options.</p> <p>See Also</p> <ul> <li>yaml.loadFile</li> </ul>"},{"location":"stimgen/AbstractStimulusGenerationMethod/#synthesize_audio","title":"synthesize_audio","text":"<p>Synthesize audio from spectrum, X.</p>"},{"location":"stimgen/BernoulliStimulusGeneration-head/","title":"Bernoulli Stimulus Generation","text":"<p>This is a stimulus generation method in which each tonotopic bin has a probability <code>p</code> of being at 0 dB, otherwise it is at -20 dB. </p>"},{"location":"stimgen/BernoulliStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- bin_prob = 0.3\n</code></pre>"},{"location":"stimgen/BernoulliStimulusGeneration/","title":"Bernoulli Stimulus Generation","text":"<p>This is a stimulus generation method in which each tonotopic bin has a probability <code>p</code> of being at 0 dB, otherwise it is at -20 dB. </p>"},{"location":"stimgen/BernoulliStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- bin_prob = 0.3\n</code></pre>"},{"location":"stimgen/BernoulliStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, X, binned_repr] = generate_stimulus(self)\n</code></pre> <p>Generate a matrix of stimuli where the matrix is of size nfft x n_trials. Bins are filled with an an amplitude of -20 or 0. Each bin is randomly filled with a change of being filled (amplitude = 0) with a probability of <code>self.bin_prob</code>.</p> <p>OUTPUTS:</p> <p>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>m x 1</code> numerical vector, the half-spectrum, where m is <code>self.get_nfft() / 2</code>, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>m x 1</code> numerical vector, the frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</p> <p>Class Properties Used:</p> <pre><code>n_bins\nbin_prob\n</code></pre>"},{"location":"stimgen/BrimijoinStimulusGeneration-head/","title":"Brimijoin Stimulus Generation","text":"<p>This is a stimulus generation method in which each tonotopic bin is filled with an amplitude value from an equidistant list with equal probability.</p>"},{"location":"stimgen/BrimijoinStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- amplitude_values = linspace(-20, 0, 6)\n</code></pre>"},{"location":"stimgen/BrimijoinStimulusGeneration/","title":"Brimijoin Stimulus Generation","text":"<p>This is a stimulus generation method in which each tonotopic bin is filled with an amplitude value from an equidistant list with equal probability.</p>"},{"location":"stimgen/BrimijoinStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has one property in addition to those inhereted from the Abstract and Abstract Binned classes. Default:</p> <pre><code>- amplitude_values = linspace(-20, 0, 6)\n</code></pre>"},{"location":"stimgen/BrimijoinStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a matrix of stimuli. Bins are filled with an amplitude value chosen from self.amplitude_values with equal probability.</p> <p>OUTPUTS:</p> <p>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>m x 1</code> numerical vector, the half-spectrum, where m is <code>self.get_nfft() / 2</code>, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>m x 1</code> numerical vector, the frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</p> <p>Class Properties Used:</p> <pre><code>n_bins\namplitude_values\n</code></pre> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration-head/","title":"Gaussian Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation method in which each frequency's amplitude is chosen according to a Gaussian distribution. This class cannot work with binned representations.</p>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract class. Defaults:</p> <pre><code>amplitude_mean = -10\namplitude_var = 3\n</code></pre>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration/","title":"Gaussian Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation method in which each frequency's amplitude is chosen according to a Gaussian distribution. This class cannot work with binned representations.</p>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract class. Defaults:</p> <pre><code>amplitude_mean = -10\namplitude_var = 3\n</code></pre>"},{"location":"stimgen/GaussianNoiseNoBinsStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<p>Generate stimuli using a binless white-noise process.</p> <p>Class Properties Used:</p> <pre><code>- amplitude_mean\n- amplitude_var\n</code></pre>"},{"location":"stimgen/GaussianNoiseStimulusGeneration-head/","title":"Gaussian Noise Stimulus Generation","text":"<p>This is a stimulus generation method in which each tonotopic bin is filled with amplitude chosen from a Gaussian distribution. This class can work with binned representations of the signals. </p>"},{"location":"stimgen/GaussianNoiseStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>amplitude_mean = -10\namplitude_var = 3\n</code></pre>"},{"location":"stimgen/GaussianNoiseStimulusGeneration/","title":"Gaussian Noise Stimulus Generation","text":"<p>This is a stimulus generation method in which each tonotopic bin is filled with amplitude chosen from a Gaussian distribution. This class can work with binned representations of the signals. </p>"},{"location":"stimgen/GaussianNoiseStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>amplitude_mean = -10\namplitude_var = 3\n</code></pre>"},{"location":"stimgen/GaussianNoiseStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<p>Generate a matrix of stimuli where the matrix is of size nfft x n_trials. Bins are filled with an amplitude value chosen randomly. from a Gaussian distribution.</p> <p>OUTPUTS:</p> <p>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</p> <p>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</p> <p>spect: <code>m x 1</code> numerical vector, the half-spectrum, where m is <code>self.get_nfft() / 2</code>, in dB.</p> <p>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</p> <p>frequency_vector: <code>m x 1</code> numerical vector, the frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</p> <p>Class Properties Used:</p> <pre><code>- n_bins\n- amplitude_mean\n- amplitude_var\n</code></pre>"},{"location":"stimgen/GaussianPriorStimulusGeneration-head/","title":"Gaussian Prior Stimulus Generation","text":"<p>This is a stimulus generation method in which the number of filled bins is selected from a Gaussian distribution with known mean and variance parameters.</p>"},{"location":"stimgen/GaussianPriorStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>- n_bins_filled_mean = 20\n- n_bins_filled_var = 1\n</code></pre>"},{"location":"stimgen/GaussianPriorStimulusGeneration/","title":"Gaussian Prior Stimulus Generation","text":"<p>This is a stimulus generation method in which the number of filled bins is selected from a Gaussian distribution with known mean and variance parameters.</p>"},{"location":"stimgen/GaussianPriorStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>- n_bins_filled_mean = 20\n- n_bins_filled_var = 1\n</code></pre>"},{"location":"stimgen/GaussianPriorStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a vector of stimuli where the bin amplitudes are -20 dB for an unfilled bin and 0 dB for a filled bin. Filled bins are chosen uniformly from unfilled bins, one at a time. The total number of bins-to-be-filled is chosen from a Gaussian distribution.</p> <p>OUTPUTS:</p> <ul> <li>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</li> <li>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</li> <li>spect: <code>m x 1</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in dB.</li> <li>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</li> <li>frequency_vector: <code>m x 1</code> numerical vector The frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</li> </ul> <p>Class Properties Used: <pre><code>- n_bins\n- n_bins_filled_mean\n- n_bins_filled_var\n</code></pre></p> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/PowerDistributionStimulusGeneration-head/","title":"Power Distribution Stimulus Generation","text":"<p>This is a stimulus generation method in which the frequencies in each bin are sampled from a power distribution learned from tinnitus examples. </p>"},{"location":"stimgen/PowerDistributionStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>distribution = []\ndistribution_filepath = ''\n</code></pre>"},{"location":"stimgen/PowerDistributionStimulusGeneration/","title":"Power Distribution Stimulus Generation","text":"<p>This is a stimulus generation method in which the frequencies in each bin are sampled from a power distribution learned from tinnitus examples. </p>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two properties in addition to those inhereted from the Abstract and Abstract Binned classes. Defaults:</p> <pre><code>distribution = []\ndistribution_filepath = ''\n</code></pre>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#build_distribution","title":"build_distribution","text":"<p>Builds the default power distribution from ATA tinnitus sample files. Saves the distribution as a vector in dB and the corresponding frequency vector.</p> <p>ARGUMENTS:</p> <ul> <li>save_path: character vector,  the path to <code>.mat</code> file where distribution should be saved.  Default: <pre><code>pathlib.join(fileparts(mfilename('fullpath')), 'distribution.mat');\n</code></pre></li> </ul> <p>OUTPUTS:</p> <ul> <li>distribution: numeric vector, the power distribution in dB.</li> </ul> <p>See Also</p> <ul> <li>PowerDistributionStimulusGeneration.from_file</li> <li>PowerDistributionStimulusGeneration.generate_stimulus</li> </ul>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#from_file","title":"from_file","text":"<p>Loads a power distribution from a <code>.mat</code> or <code>.csv</code> file into the object.</p> <p>See Also</p> <ul> <li>PowerDistributionStimulusGeneration.build_distribution</li> </ul>"},{"location":"stimgen/PowerDistributionStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generates stimuli by assigning the power in each bin by sampling from a power distribution learned from ATA tinnitus examples.</p> <p>OUTPUTS:</p> <ul> <li>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</li> <li>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</li> <li>spect: <code>m x 1</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in dB.</li> <li>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</li> <li>frequency_vector: <code>m x 1</code> numerical vector The frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</li> </ul> <p>Class Properties Used: <pre><code>- n_bins\n</code></pre></p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration-head/","title":"Uniform Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation method in which each frequency is chosen from a uniform distribution on <code>[-20, 0]</code> dB. This class does not work with binned representations of the stimuli.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method does not have any unique properties in addition to those inhereted from the Abstract class.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration/","title":"Uniform Noise No Bins Stimulus Generation","text":"<p>This is a stimulus generation method in which each frequency is chosen from a uniform distribution on <code>[-20, 0]</code> dB. This class does not work with binned representations of the stimuli.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method does not have any unique properties in addition to those inhereted from the Abstract class.</p>"},{"location":"stimgen/UniformNoiseNoBinsStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<p>Generate stimuli using a binless white-noise process.</p> <p>Class Properties Used: <pre><code>- n_bins\n</code></pre></p>"},{"location":"stimgen/UniformNoiseStimulusGeneration-head/","title":"Uniform Noise Stimulus Generation","text":"<p>This class does not have any unique properties as it's purpose is to generate a uniformly noisy stimulus signal. This class can work with binned representations of the stimuli.  </p>"},{"location":"stimgen/UniformNoiseStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method does not have any unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p>"},{"location":"stimgen/UniformNoiseStimulusGeneration/","title":"Uniform Noise Stimulus Generation","text":"<p>This class does not have any unique properties as it's purpose is to generate a uniformly noisy stimulus signal. This class can work with binned representations of the stimuli.  </p>"},{"location":"stimgen/UniformNoiseStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method does not have any unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p>"},{"location":"stimgen/UniformNoiseStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generate a vector of stimuli where the bin amplitudes are chosen randomly from a uniform distribution over [-20, 0] dB.</p> <p>OUTPUTS:</p> <ul> <li>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</li> <li>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</li> <li>spect: <code>m x 1</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in dB.</li> <li>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</li> <li>frequency_vector: <code>m x 1</code> numerical vector The frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</li> </ul> <p>Class Properties Used:</p> <pre><code>- n_bins\n</code></pre> <p>See Also</p> <ul> <li>AbstractBinnedStimulusGenerationMethod.get_freq_bins</li> <li>AbstractStimulusGenerationMethod.generate_stimuli_matrix</li> </ul>"},{"location":"stimgen/UniformPriorStimulusGeneration-head/","title":"Uniform Prior Stimulus Generation","text":"<p>This is a stimulus generation method in which the number of filled bins is selected from a uniform distribution on <code>[min_bins, max_bins]</code>.</p>"},{"location":"stimgen/UniformPriorStimulusGeneration-head/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p> <pre><code>- min_bins = 10\n- max_bins = 50\n</code></pre>"},{"location":"stimgen/UniformPriorStimulusGeneration/","title":"Uniform Prior Stimulus Generation","text":"<p>This is a stimulus generation method in which the number of filled bins is selected from a uniform distribution on <code>[min_bins, max_bins]</code>.</p>"},{"location":"stimgen/UniformPriorStimulusGeneration/#unique-properties","title":"Unique Properties","text":"<p>This stimulus generation method has two unique properties in addition to those inhereted from the Abstract and Abstract Binned classes.</p> <pre><code>- min_bins = 10\n- max_bins = 50\n</code></pre>"},{"location":"stimgen/UniformPriorStimulusGeneration/#generate_stimulus","title":"generate_stimulus","text":"<pre><code>[stim, Fs, spect, binned_repr, frequency_vector] = generate_stimulus(self)\n</code></pre> <p>Generates stimuli by generating a frequency spectrum with -20 dB and 0 dB amplitudes based on a tonotopic map of audible frequency perception.</p> <p>OUTPUTS:</p> <ul> <li>stim: <code>n x 1</code> numerical vector, the stimulus waveform, where <code>n</code> is <code>self.get_nfft() + 1</code>.</li> <li>Fs: <code>1x1</code> numerical scalar, the sample rate in Hz.</li> <li>spect: <code>m x 1</code> numerical vector, the half-spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in dB.</li> <li>binned_repr: <code>self.n_bins x 1</code> numerical vector, the binned representation.</li> <li>frequency_vector: <code>m x 1</code> numerical vector The frequencies associated with the spectrum, where <code>m</code> is <code>self.get_nfft() / 2</code>, in Hz.</li> </ul> <p>Class Properties Used: <pre><code>- n_bins\n- n_bins_filled_mean\n- n_bins_filled_var\n</code></pre></p>"}]}